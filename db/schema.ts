// src/db/schema.ts
import {
  pgTable, text, varchar, timestamp, primaryKey, integer, doublePrecision, date, serial, boolean, index, uniqueIndex
} from 'drizzle-orm/pg-core';
import { relations, sql } from 'drizzle-orm';

/**
 * ==============================
 * Auth.js (NextAuth) tables
 * Schema compatible with @auth/drizzle-adapter for PostgreSQL
 * ==============================
 */

// Users (Auth.js expects a string id; we'll let NextAuth generate it)
export const users = pgTable('users', {
  id: text('id').default(sql`gen_random_uuid()::text`).primaryKey(), // string id (e.g., cuid) generated by NextAuth
  name: varchar('name', { length: 255 }),
  email: varchar('email', { length: 255 }).unique(),
  emailVerified: timestamp('emailVerified', { withTimezone: true }),
  image: text('image'), // avatar URL
});

// Accounts (OAuth providers)
export const accounts = pgTable('accounts', {
  userId: text('userId')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  type: varchar('type', { length: 255 }).notNull(),
  provider: varchar('provider', { length: 255 }).notNull(),
  providerAccountId: varchar('providerAccountId', { length: 255 }).notNull(),
  refresh_token: text('refresh_token'),
  access_token: text('access_token'),
  expires_at: integer('expires_at'),
  token_type: varchar('token_type', { length: 255 }),
  scope: text('scope'),
  id_token: text('id_token'),
  session_state: text('session_state'),
}, (table) => ({
  // Each provider+account must be unique
  providerProviderAccountIdIdx: uniqueIndex('accounts_provider_providerAccountId_idx').on(
    table.provider, table.providerAccountId
  ),
}));

// Sessions (for JWT-less session strategy)
export const sessions = pgTable('sessions', {
  sessionToken: varchar('sessionToken', { length: 255 }).primaryKey(),
  userId: text('userId')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  expires: timestamp('expires', { withTimezone: true }).notNull(),
});

// Email magic link tokens (required by adapter)
export const verificationTokens = pgTable('verificationTokens', {
  identifier: varchar('identifier', { length: 255 }).notNull(),
  token: varchar('token', { length: 255 }).notNull(),
  expires: timestamp('expires', { withTimezone: true }).notNull(),
}, (table) => ({
  tokenIdx: uniqueIndex('verification_token_token_idx').on(table.token),
  identifierTokenIdx: uniqueIndex('verification_token_identifier_token_idx').on(
    table.identifier, table.token,
  ),
}));

/**
 * ==============================
 * App tables: Trips & Locations
 * ==============================
 */

// Trips belong to a user (Auth users.id is text)
export const trips = pgTable('trips', {
  id: serial('id').primaryKey(), // simple incremental id for URLs like /trip/123
  userId: text('userId')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),

  title: varchar('title', { length: 120 }).notNull(),
  description: text('description'), // optional
  startDate: date('start_date').notNull(),
  endDate: date('end_date').notNull(),

  imageUrl: text('image_url'), // optional image URL

  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(), // update in app code on edits
}, (table) => ({
  userIdIdx: index('trips_userId_idx').on(table.userId),
  dateIdx: index('trips_date_idx').on(table.startDate, table.endDate),
}));

// Locations belong to a trip. We store address + lat/lng + display order.
export const locations = pgTable('locations', {
  id: serial('id').primaryKey(),
  tripId: integer('trip_id')
    .notNull()
    .references(() => trips.id, { onDelete: 'cascade' }),

  title: varchar('title', { length: 120 }).notNull(),
  address: text('address'), // user-entered address; optional if they drop a pin later
  lat: doublePrecision('lat').notNull(),
  lng: doublePrecision('lng').notNull(),

  order: integer('order').notNull().default(1), // display/route order, 1..N

  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  tripIdx: index('locations_trip_idx').on(table.tripId),
  tripOrderIdx: index('locations_trip_order_idx').on(table.tripId, table.order),
}));

/**
 * ==============================
 * Relations (nice for typed joins)
 * ==============================
 */
export const usersRelations = relations(users, ({ many }) => ({
  trips: many(trips),
  accounts: many(accounts),
  sessions: many(sessions),
}));

export const tripsRelations = relations(trips, ({ one, many }) => ({
  user: one(users, {
    fields: [trips.userId],
    references: [users.id],
  }),
  locations: many(locations),
}));

export const locationsRelations = relations(locations, ({ one }) => ({
  trip: one(trips, {
    fields: [locations.tripId],
    references: [trips.id],
  }),
}));
